# 南川算法精讲 | 华为 OJ 困难级别全部题解（下）

## 华为机试-将真分数分解为埃及分数

### 题目描述

分子为 1 的分数称为埃及分数。现输入一个真分数(分子比分母小的分数，叫做真分数)，请将该分数分解为埃及分数。如：8/11 = 1/2+1/5+1/55+1/110。

（南川补充：此外，每个埃及分数的分母不得重复）

#### 输入描述

```
输入一个真分数，String型
```

#### 输出描述

```
输出分解后的string
```

### 示例一

#### 输入

```
8/11
```

#### 输出

```
1/2+1/5+1/55+1/110
```

### 思路一：迭代+深搜索

这道题如果第一次见，还是比较难的，原因在于我们并不知道一个真分数最终将由几个埃及分数构成。如果直接使用暴力枚举，我们也很难理清枚举的上限。

但这道题有个关键的约束，就是目标分数小于 1，而每个埃及分数的分子都是 1，这就使每一个埃及分数的可能值有了一定的确切边界。

考虑示例中的`8/11`，假设我们首先尝试第一个最大的埃及分数为`1/2`，这就导致其余的埃及分数必然小于`8/11-1/2=15/22`；

接着再尝试第二个最大的埃及分数`1/3`，使得剩余分数必然小于`15/22-1/3=23/66`；

接着是`1/4`，剩余分数为`23/66-1/4=8/132`。而这个数，已经有点不一样了。因为接下来如果再加一个埃及分数的话，那么它必须小于`1/17`，也就是中间的`5-16`都不用试了。

很显然，如果我们紧接着再加上一个`1/17` ，接下来的数将更小。以此往复。

因此，我们必须要定义剪枝条件，否则这将迭代没有尽头。

#### 剪枝的目标

为了更好地剪枝，我们需要再次明确问题的优化目标。

根据埃及分数的问题背景，我们补充对题的理解。

首先，显然埃及分数的解不唯一。举个例子：`4/24=1/6=1/8+1/24`，这已经是两种埃及分数分解的方案。

因此我们迭代过程中有必要思考一下其他的优化目标。

其中第一个额外目标就是，使埃及分数的个数最小，如上，`1/6`就要明显优于`1/8+1/24`。

第二个额外目标就是，在同个数的情况下，最小的埃及分数尽可能大，也就是说最大的分母尽可能小，这些都是非常符合常识的。

### 剪枝的关键

其实，两个额外目标（个数少，分母小）之间还有微妙的制衡关系。

例如，我们假设期望最大个数为 3，考虑 8/11 这个真分数，在尝试使用`1/2+1/3`这两个埃及分数之后，显然，仅仅考虑第一个额外目标我们就知道，此路不通，因为没有任何一个埃及分数等于`23/66`，因此不可能仅仅通过三个埃及分数（其中两个为`1/2`和`1/3`）。

于是，迭代开始回溯，我们继续考虑考虑`1/2+1/4`。容易知道，依旧没有合适的解。

紧接着，我们发现，，只要第一个埃及分数是`1/2`，总埃及分数限制不超过 3，接下来几乎都没有解，但我们总不能一直迭代下去吧？实际上这里也有隐含剪枝条件，也就是从 2 倍的埃及分数必须大于等于剩余分数，否则继续遍历将始终小于剩余分数，没有意义。

基于此，我们发现，只要设定了第一个目标（埃及分数个数不超过 K），第二个目标就几乎无需考虑，因为对于第 i 个埃及分数，始终有一个剪枝条件就是`f(i)*(K-i)>=F(i)`，这里的`f(i)`指第 i 个埃及分数的值，`F(i)`指剩余分数大小。在遍历的过程中一旦不满足，即可回溯，直到当`i=1`时也不满足才返回没有结果的异常。例如对于目标分数`8/11`，目标最大个数为`3`的情况，当对第一个埃及分数遍历超过 4 时，即可直接返回异常，因为`1/5 * 3 < 8/11`。

由此，我们可以写出一个能在有限时间内找到解的算法，唯一的问题就是必须限制埃及分数的最大个数。

### 思路一的编程实现：DFS

考虑到这题只是一个机试，因此，测例还是比较友好的，我们姑且设置埃及分数的最大个数为 5。

这里，值得注意的是，分数加减有精度误差，判等时需要做精度控制。

编写如下代码。

```python
import math
PRECISION = 1e-16
MAX_DENOMINATOR = 1000

def DFS(target):
    def solve(target, chain, n):
        L = max(math.floor(1 / target), 1 + chain[-1] if chain else 0)
        R = min(math.ceil((n - len(chain)) / target) + 1, MAX_DENOMINATOR)
        # print({'target': round(target, 4), 'chain': chain, 'L': L, 'R': R})
        for i in range(L, R):
          # 控制差小于精度，等价于数相等
            if abs(1/i - target) < PRECISION:
                ans_list.append('+'.join(['1/' + str(i) for i in chain + [i]]))
            elif len(chain) < n and target > 1/i:
                ans = solve(target - 1 / i, chain + [i], n)
                if ans:
                    return ans

    ans_list = []
    solve(target, [], 4)
    print('Possible ans: ')
    for ans in ans_list:
        print(ans)
```

对于`DFS(8/11)`的结果如下，它列出了最多四个埃及分数的可能的解。

```text
Possible ans:
1/2+1/5+1/40+1/440
1/2+1/5+1/44+1/220
1/2+1/5+1/45+1/198
1/2+1/5+1/55+1/110
1/2+1/5+1/70+1/77
1/2+1/6+1/17+1/561
1/2+1/6+1/18+1/198
1/2+1/6+1/21+1/77
1/2+1/6+1/22+1/66
1/2+1/7+1/12+1/924
1/2+1/7+1/14+1/77
1/2+1/8+1/10+1/440
1/2+1/8+1/11+1/88
1/3+1/4+1/7+1/924
```

### 思路一的优化：BFS

虽然上述 DFS 的方法，已经能够解决这道题，但它只是简单罗列了所有满足最大固定子分数个数的解而已，假设一个真分数既可以展开成 3 个埃及分数，也能展开 4 个，使用 DFS 将必须迭代获得所有解最后才能知道最优解，显然有效率优化的空间。而解决方案就是 BFS。

使用 BFS，我们可以针对性地按行遍历，先遍历只使用 1 个埃及分数的情况，若无解再扩展成 2 个，接着是 3 个，直到有解。而要**实现 BFS 的关键就是使用队列**，因此我们简单修改一下原来的代码，使之满足 BFS 的要求。

此外，由于使用 BFS 横向搜索，所以有必要定义一个分母上限，防止搜索过长。这想起来其实挺有意思的，虽然无论使用 DFS 还是 BFS，搭配使用最大分母上限与最大个数上限都有助于提高算法效率。但相对来说，DFS 更依赖最大个数上限（也就是层数限制），而 BFS 更依赖最大分母上限（即每层的个数上限）。

代码如下。

```python
from queue import Queue
import math
PRECISION = 1e-16
MAX_WIDTH = 5
MAX_DENOMINATOR = 1000


def is_equal(target, i):
    return abs(target - 1/i) < PRECISION


def run(target):
    q = Queue()
    ans_list = []

    def layer_solve(target, chain):
        L = max(math.ceil(1/target), chain[-1]+1 if chain else 2)
        for i in range(L, MAX_DENOMINATOR):
            if is_equal(target, i):
                ans_list.append(chain + [i])
                return
            # 判断是否找到解，一旦找到，便不再纵向遍历
            elif 1/i < target and len(ans_list) == 0:
                if (MAX_WIDTH - len(chain)) / i >= target:
                    q.put((target-1/i, chain+[i]))
                else:
                    break

    layer_solve(target, [])
    while not q.empty():
        layer_solve(*q.get())
```

在这段代码中相较于上段代码，首先是引入了`queue`包，此外单独抽离出判等函数，使算法的逻辑更清晰，可扩展性更强。

简单运行测例`run(8/11)`可以得到如下结果。

```text
ans_list:
[2, 5, 40, 440]
[2, 5, 44, 220]
[2, 5, 45, 198]
[2, 5, 55, 110]
[2, 5, 70, 77]
[2, 6, 17, 561]
[2, 6, 18, 198]
[2, 6, 21, 77]
[2, 6, 22, 66]
[2, 7, 12, 924]
[2, 7, 14, 77]
[2, 8, 10, 440]
[2, 8, 11, 88]
[3, 4, 7, 924]
```

看上去和 DFS 的结果没啥区别，也是 4 层。

但是，如果我们换一个测例，比如`run(3/13)`，差异就体现出来了。

```text
ans_list:
[5, 35, 455]
[5, 39, 195]
[5, 45, 117]
[6, 16, 624]
[6, 18, 117]
[6, 26, 39]
[7, 13, 91]
```

可以看到，所有的解都只有三个元素，说明算法在第三层即找到解，而避免了搜索第四层，这显然是满足了我们优化算法的目标的。

### Python 对分数处理的另一种替代方案

Python 其实有一个内置包叫`fraction`用于处理分数，两个`Fraction`对象相减得到的结果也是`Fraction`，此外还会自动月分，比如`Fraction(2, 4)`这个数，它就等于`Fraction(1, 2)`，如果调用它的`numerator`（分子）属性会发现就等于 1，相应地，它的`denominator`（分母）属性就是等于 2。这样的性质非常适合用来解决这道题，因为它首先避免了精度损失，此外还可以在判等时直接判断分子是否为 1，效率应该是更高的（至少可读性更高）。

以下简单给出一份基于`Fraction`的代码。

```python
from fractions import Fraction
import math

PRECISION = 1e-16
MAX_DENOMINATOR = 1000


def DFS_fraction(target):

    def solve(target: Fraction, chain, n):
        if target.numerator == 1:
            ans_list.append('+'.join(['1/' + str(i) for i in chain]))
        elif len(chain) < n:
            L = max(math.ceil(1 / target), 1 + chain[-1] if chain else 0)
            R = min(math.ceil((n - len(chain)) / target) + 1, MAX_DENOMINATOR)
            # print({'target': target, 'chain': chain, 'L': L, 'R': R})
            for i in range(L, R):
                solve(target - Fraction(1, i), chain + [i], n)

    ans_list = []
    solve(Fraction(target), [], 3)
    print('ALL THE ANS: ')
    for ans in ans_list:
        print(ans)


if __name__ == '__main__':
    DFS_fraction(4 / 13)

```

不过值得注意的是，尽管基于`Fraction`的处理是精确的，但是仍然会有一些违反普通人常识的设计，比如当多个分数相减，导致值为 0 时，可能会出现以下的结果。例如：

![image-20200908193541873](https://mark-vue-oss.oss-cn-hangzhou.aliyuncs.com/picgo/image-20200908193541873.png)

我们其实早已经知道`8/11 = 1/2 + 1/5 + 1/55 + 1/110`，然而通过分数计算得到的结果却让我们有一些难以接受，尽管如此，在处理分数加减上，它还是比纯粹使用浮点数，来的更人性化一些。

如果你的项目需要频繁处理财务之类的数据，那么强烈推荐你了解`fraction`这个模块，比如在四大工作的朋友们。

### 思路二：数论解法

首先上链接：[埃及分数(迭代加深搜索，斐波那契分解分数)\_zyz_bz 的博客-CSDN 博客](https://blog.csdn.net/zyz_bz/article/details/89515096)

接着上公式。

$$
当a<b，a\in N^+,b\in N^+时，\\
令b=a*p+r，其中p=a//b, r=a\%b,则有
\\
\frac{a}{b} = \frac{a}{a*p+r} = \frac{(ap+r)+(r-a)}{(a*p+r)(p+1)} = \frac{1}{p+1}+\frac{a-r}{(a*p+r)(p+1)}
$$

这就是大名鼎鼎的斐波那契分解法，我们很容易得知$\frac{a}{b}$可以分解为$\frac{1}{p+1}$（一个埃及分数）与另外一个分数。

这里，最值得注意的是，第二个分数的分子比原分数要小（$r>0, a-r<a$），因此对第二个分数继续展开，总能在有限次数下压缩到最小（即分子为 1）。

此外，若我们记$r=0$，可以立即得到该分数变成$\frac{1}{p*(p+1)}$，它正是一个埃及分数。

总之，我们容易得证，该分解是收敛必有解的。

基于此，我们实现更帅气的数论解法。

### 思路二的编程实现：基于数论

直接使用递归实现。

```python
def run(a: int, b: int):

    def solve(a: int, b: int):
        print({'a': a, 'b': b})
        p = b // a
        r = b % a
        yield p+1

        a_ = a - r
        b_ = (a*p+r) * (p+1)

        if a_ == 1:
            yield b_
        else:
            yield from solve(a_, b_)

    ans = ' + '.join('1/%d' % i for i in solve(a, b))
    print('ANS of {} / {}'.format(a, b))
    print(ans)
    return ans


if __name__ == '__main__':
    run(8, 11)
```

结果如下：

```text
{'a': 8, 'b': 11}
{'a': 5, 'b': 22}
{'a': 3, 'b': 110}
ANS of 8 / 11
1/2 + 1/5 + 1/37 + 1/4070
```

可以看到，只要执行几次函数就得到结果，不得不说，速度是搜索法的上百倍甚至上万倍。。。

唯一的缺点就是受限于该数论的分解范式，很难得到最优的解，除非我们对我们的斐波那契分解做更细致地调整。

基于此，我是不满意目前的结果的，但我也无法从数论角度给出更好的解决方案了，毕竟，这个分解关系式，我是想不出来的。

此处假装 at 数论大神。

### 该题总结

这题真地还是很有意思的，只要你想深挖，可以充分锻炼自己的 DFS、BFS 算法设计能力，包括搜索时的技巧（而非简单的搜索）。

最后，借着数论的解决方法再度升华本题的价值，实属经典，我也就不吝啬笔墨了。

## 华为机试-素数伴侣

### 题目描述

若两个正整数的和为素数，则这两个正整数称之为“素数伴侣”，如 2 和 5、6 和 13，它们能应用于通信加密。现在密码学会请你设计一个程序，从已有的 N（N 为偶数）个正整数中挑选出若干对组成“素数伴侣”，挑选方案多种多样，例如有 4 个正整数：2，5，6，13，如果将 5 和 6 分为一组中只能得到一组“素数伴侣”，而将 2 和 5、6 和 13 编组将得到两组“素数伴侣”，能组成“素数伴侣”最多的方案称为“最佳方案”，当然密码学会希望你寻找出“最佳方案”。

### 输入描述

```
输入说明
1 输入一个正偶数n
2 输入n个整数
```

### 输出描述

```
求得的“最佳方案”组成“素数伴侣”的对数。
```

### 示例 1

#### 输入

```
4
2 5 6 13
```

#### 输出

```
2
```

### 解题思路

本题需要使用匈牙利算法，对该算法不了解的先移步我另外一篇有趣的文章 [求解：《三十而已》中王曼妮的恋爱匹配问题？](https://mp.weixin.qq.com/s?__biz=MzI1NTU4MDcwMg==&mid=2247486848&idx=1&sn=223319630f521c115c2366132d50ce8c&chksm=ea3282f1dd450be7a0055293f17caf353c53ad2d2616ada7ff0e7b79710e9f81385a487b94b3&token=1462341929&lang=zh_CN#rd)

因为偶数与偶数相加、奇数与奇数相加都必定不是素数。所以可以把偶数和奇数分列两个阵营，也就是二分图，然后使用匈牙利算法求解即可。值得注意的是，对于每一个偶数，对方阵营中是否能与该偶数匹配需要遍历相加判断得出。

代码与测例如下，答案是 25。

```python
def is_prime(x: int):
    for i in range(2, int(x**.5)):
        if x % i == 0:
            return 0
    return 1


def main(s):
    boys = []
    girls = []
    for i in s.split():
        i = int(i)
        if i % 2 == 0:
            boys.append(i)
        else:
            girls.append(i)

    def find_girl(boy_i):
        for (girl_i, girl_v) in enumerate(girls):
            if not girls_visited[girl_i] and is_prime(boys[boy_i] + girl_v):
                girls_visited[girl_i] = True
                if girls_matched[girl_i] is None or find_girl(girls_matched[girl_i]):
                    girls_matched[girl_i] = boy_i
                    return True
        return False

    girls_matched = [None] * len(girls)
    for (boy_i, boy_v) in enumerate(boys):
        girls_visited = [False] * len(girls)
        find_girl(boy_i)
        # print(girls_matched)
    ans = len([i for i in girls_matched if i is not None])
    print(ans)
    return ans


if __name__ == '__main__':
    s = '''58
    621 10618 19556 29534 25791 11133 5713 26642 25994 16095 6618 11447 29386 24436 22551 21467 2633 25704 29460 24325 8964 4087 10560 6478 9615 5119 1114 6773 9409 21549 15336 18995 2151 27404 6296 21066 3147 27037 6177 5650 16224 14352 8999 991 3012 16447 17799 16265 27163 24118 9766 15355 6161 3909 19451 16838 9113 10877'''
    main(s.splitlines()[1])
```

### 该题总结

很多题，如果解决问题的方法上偏了，就很难解决了。就像这道题，如果不知道匈牙利算法，不知道图论的一些知识，就很难做出来。

不过，这道题还有一个更大的杀器：**带树开花算法**。该算法可用于解决一般图的最大流问题，由于该题只是二分图的匹配，因此就没必要使用这么通用/底层/复杂的算法了。这个有时间再补吧！

## 华为 OJ 所有难题总结

总体来说，没有想象中那么难，按照我的这三篇文章来刷，三天时间（或者一天）即可全部掌握。

Anyway，暴力搜索、DFS、BFS、回溯、动态规划、数论、图论（例如最短路径），这些个概念还是比较重要的，在此基础上再好好研究一下对字符串的操作（比如正则匹配的基本实现）与位运算，可以拿下绝大多数算法题。

我们下期再见！
